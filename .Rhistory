mutate(MED_NAME = str_to_title(MED_NAME)) %>%
# filter rows with no significant associations
group_by(MED_NAME) %>%
filter(any(!is.na(OR))) %>%
ungroup() %>%
# plot
ggplot(aes(x = YearsPrescription,
y = MED_NAME,
fill = log10(OR))) +
geom_tile(color = "black") +
geom_text(aes(label = round(OR, 1)), size = 4) +
theme_classic() +
facet_grid(MED_GROUP~., scales = "free_y", space = "free",
switch = "y", drop = FALSE, margins = FALSE) +
theme(strip.placement = "outside",
strip.background = element_rect(fill = NA, colour = NA),
panel.spacing = unit(0.2, "cm")) +
ylab("") +
xlab("Age at prescription (years)") +
scale_x_discrete(labels = c("0-2", "2-12", "12-18", ">18")) +
scale_fill_gradient2(name = "OR",
labels = c("0", "", "1", "", "Inf"),
low = "#00b4fb",
mid = "#F5F5F5",
high = "#ff8422",
midpoint = 0,
na.value = "#F5F5F5",
limits = c(-2, 2),
oob = scales::oob_squish_any)
p_asm
df_match1 %>%
# merge in patient ID and group label
distinct(PatientId, group) %>%
left_join(df_med, by = "PatientId") %>%
na.omit %>%
## fixed bin width by ILAE age categories
mutate(YearsPrescription = cut(YearsPrescription, breaks = c(0, 2, 12, 18, Inf))) %>%
# count ASM prescription per group; for each age bin (year)
group_by(group, MED_NAME, YearsPrescription) %>%
summarize(test = n()) %>%
# prepare Fisher's test
pivot_wider(names_from = group, values_from = test) %>%
rename(N = `FALSE`, Y = `TRUE`) %>%
ungroup() %>%
# force complete all cases
complete(MED_NAME, YearsPrescription) %>%
replace(is.na(.), 0) %>%
mutate(N_out = max(N)-N, # max value is equal to sample size due to ontology str
Y_out = max(Y)-Y) %>%
rowwise() %>%
# do Fisher's test
mutate(P = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$p.value,
OR = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$estimate,
CI1 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[1]],
CI2 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[2]]) %>%
# adjust for multiple testing
mutate(P = p.adjust(P, method = "bonferroni")) %>%
# force OR with insignificant pvalues to be NA
mutate(OR = ifelse(P > 0.05, NA, OR)) %>%
# merge in group description for facets
left_join(asm_map, by = "MED_NAME") %>%
# define factor levels
mutate(MED_NAME = factor(MED_NAME, levels = sort(unique(asm_vec)))) %>%
# # frequency filter; optional
# ungroup() %>%
# mutate(freqY = Y/max(Y)) %>%
# mutate(freqN = N/max(N)) %>%
# filter(freqY > 0.01 & freqN > 0.01)
# another frequency filter
ungroup() %>%
mutate(freqY = Y/max(Y)) %>%
mutate(freqN = N/max(N)) %>%
mutate(OR = ifelse(freqY > 0.01 & freqN > 0.01, OR, NA))
# take strict matched case-control set
df_heatmap <- df_match1 %>%
# merge in patient ID and group label
distinct(PatientId, group) %>%
left_join(df_med, by = "PatientId") %>%
na.omit %>%
## fixed bin width by ILAE age categories
mutate(YearsPrescription = cut(YearsPrescription, breaks = c(0, 2, 12, 18, Inf))) %>%
# count ASM prescription per group; for each age bin (year)
group_by(group, MED_NAME, YearsPrescription) %>%
summarize(test = n()) %>%
# prepare Fisher's test
pivot_wider(names_from = group, values_from = test) %>%
rename(N = `FALSE`, Y = `TRUE`) %>%
ungroup() %>%
# force complete all cases
complete(MED_NAME, YearsPrescription) %>%
replace(is.na(.), 0) %>%
mutate(N_out = max(N)-N, # max value is equal to sample size due to ontology str
Y_out = max(Y)-Y) %>%
rowwise() %>%
# do Fisher's test
mutate(P = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$p.value,
OR = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$estimate,
CI1 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[1]],
CI2 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[2]]) %>%
# adjust for multiple testing
mutate(P = p.adjust(P, method = "bonferroni")) %>%
# force OR with insignificant pvalues to be NA
mutate(OR = ifelse(P > 0.05, NA, OR)) %>%
# merge in group description for facets
left_join(asm_map, by = "MED_NAME") %>%
# define factor levels
mutate(MED_NAME = factor(MED_NAME, levels = sort(unique(asm_vec)))) %>%
# # frequency filter; optional
# ungroup() %>%
# mutate(freqY = Y/max(Y)) %>%
# mutate(freqN = N/max(N)) %>%
# filter(freqY > 0.01 & freqN > 0.01)
# another frequency filter
ungroup() %>%
mutate(freqY = Y/max(Y)) %>%
mutate(freqN = N/max(N)) %>%
mutate(OR = ifelse(freqY > 0.01 & freqN > 0.01, OR, NA)) %>%
filter(MED_NAME %in% c("vigabatrin", "midazolam", "diazepam", "clonazepam", "valproic acid", "topiramate", "cannabidiol", "phenytoin"))
# plot
p_asm <- df_heatmap %>%
mutate(MED_NAME = str_to_title(MED_NAME)) %>%
# filter rows with no significant associations
group_by(MED_NAME) %>%
filter(any(!is.na(OR))) %>%
ungroup() %>%
# plot
ggplot(aes(x = YearsPrescription,
y = MED_NAME,
fill = log10(OR))) +
geom_tile(color = "black") +
geom_text(aes(label = round(OR, 1)), size = 4) +
theme_classic() +
facet_grid(MED_GROUP~., scales = "free_y", space = "free",
switch = "y", drop = FALSE, margins = FALSE) +
theme(strip.placement = "outside",
strip.background = element_rect(fill = NA, colour = NA),
panel.spacing = unit(0.2, "cm")) +
ylab("") +
xlab("Age at prescription (years)") +
scale_x_discrete(labels = c("0-2", "2-12", "12-18", ">18")) +
scale_fill_gradient2(name = "OR",
labels = c("0", "", "1", "", "Inf"),
low = "#00b4fb",
mid = "#F5F5F5",
high = "#ff8422",
midpoint = 0,
na.value = "#F5F5F5",
limits = c(-2, 2),
oob = scales::oob_squish_any)
p_asm
plot3 <- p_asm
## data
# load UMLS concepts
# source: nlm.nih.gov/research/umls/
umls_map <- read.delim("~/PATH/data/MRCONSO.RRF",
sep = "|", header = FALSE)
## data
# load UMLS concepts
# source: nlm.nih.gov/research/umls/
umls_map <- read.delim("/Volumes/CCF/EMR cohort study/Surgery cohort/data/MRCONSO.RRF",
sep = "|", header = FALSE)
umls_map <- umls_map %>%
as_tibble() %>%
filter(V2 == "ENG") %>%
distinct(V1, V15) %>%
rename(ConceptID = V1, ConceptDesc = V15)
# only keep one description per term (multiple vocabularies)
umls_map <- umls_map %>%
group_by(ConceptID) %>%
filter(row_number() == 1)
# anti-join UMLS vs HPO
df_concepts <- df_genes %>%
ungroup %>%
anti_join(hpo_map, by = "ConceptID")
# get concept descriptions
# note: MRCONSO.RRF represents only a common subset of concepts; the full set of
# the metathesaurus is impractically large for the purpose of this analysis
# some manual annotation downstream will be necessary
df_concepts <- df_concepts %>%
left_join(umls_map, by = "ConceptID")
# save total number of concepts and concepts mapped to HPO
stats_concepts <- tibble(n_all = nrow(df_genes),
n_nonhpo = nrow(df_concepts)) %>%
mutate(ratio = n_nonhpo/n_all, diff = n_all-n_nonhpo)
# find and save list of most common concepts
df_commonconcepts <- df_concepts %>%
count(ConceptID, ConceptDesc) %>%
arrange(desc(n))
# subset to matched cohort; cross-sectional for now
df_conceptmatch <- df_match1 %>%
distinct(PatientId, group) %>%
left_join(df_concepts[, c("PatientId", "ConceptID", "ConceptDesc")],
by = "PatientId") %>%
distinct()
# count by group, then do Fisher's test
df_conceptmatch <- df_conceptmatch %>%
group_by(group) %>%
count(ConceptID) %>%
pivot_wider(names_from = group, values_from = n) %>%
rename(N = `FALSE`, Y = `TRUE`) %>%
mutate(Y = replace_na(Y, 0)) %>%
mutate(N = replace_na(N, 0)) %>%
mutate(N_out = max(N)-N, Y_out = max(Y)-Y) %>% # likewise, max group value matches sample size due to ontology str
rowwise() %>%
# do Fisher's test
mutate(P = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$p.value,
OR = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$estimate,
CI1 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[1]],
CI2 = fisher.test(matrix(c(Y, Y_out, N, N_out), nrow = 2, ncol = 2))$conf.int[[2]]) %>%
# adjust for multiple testing, keep original values
ungroup() %>%
mutate(P_i = P) %>%
mutate(P = p.adjust(P, method = "bonferroni"))
## QQ plot
pqq <- gg_qqplot(df_conceptmatch$P_i) +
theme_classic() +
annotate(geom = "text", x = -Inf, y = Inf,
hjust = -0.15, vjust = 1 + 0.15 * 3,
label = sprintf("  Î»    = %.2f", inflation(df_conceptmatch$P_i)),
size = 5) +
coord_equal() +
theme(aspect.ratio = 1) +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_hline(yintercept = -log10(0.05/length(unique(df_match1$ConceptID))), linetype = "dashed", col = "red")
# keep significant associations
df_conceptmatch <- df_conceptmatch %>%
filter(P < 0.05)
# get descriptions
df_conceptmatch <- df_conceptmatch %>%
left_join(umls_map, by = "ConceptID")
# manual annotation (labels missing in MRCONSO.RFF)
df_conceptmatch[df_conceptmatch$ConceptID == "C0478107", ]$ConceptDesc <- NA
df_conceptmatch[df_conceptmatch$ConceptID == "C0476431", ]$ConceptDesc <- NA
df_conceptmatch[df_conceptmatch$ConceptID == "C2875116", ]$ConceptDesc <- "Generalized epilepsy and epileptic syndromes, intractable"
df_conceptmatch[df_conceptmatch$ConceptID == "C2910620", ]$ConceptDesc <- "Screening for cardiovascular disorders"
df_conceptmatch[df_conceptmatch$ConceptID == "C3161331", ]$ConceptDesc <- "Unspecified intellectual disabilities"
df_conceptmatch[df_conceptmatch$ConceptID == "C0341102", ]$ConceptDesc <- "Gastroesophageal reflux disease"
df_conceptmatch[df_conceptmatch$ConceptID == "C2911172", ]$ConceptDesc <- "Other specified health status"
df_conceptmatch[df_conceptmatch$ConceptID == "C2911188", ]$ConceptDesc <- "Other long term drug therapy"
# forest plot
p_forest_nonhpo <- df_conceptmatch %>%
na.omit %>%
slice_max(order_by = OR, n = 8, with_ties = FALSE) %>%
ggplot(aes(y = reorder(ConceptDesc, OR))) +
geom_point(aes(x = OR), shape = 15, size = 3) +
geom_linerange(aes(xmin = CI1, xmax = CI2)) +
geom_vline(xintercept = 1, linetype = "dashed") +
scale_x_continuous(trans = 'log10',
oob = scales::oob_squish_infinite) +
scale_y_discrete(labels = label_wrap(30)) +
expand_limits(x = 1) +
theme_classic() +
ylab("") +
xlab("Odds ratio (95% CI, log scale)")
p_forest_nonhpo
pqq
plot1
plot2
plot3
plot_row <- cowplot::plot_grid(plot2 + theme(legend.position = "none"),
plot3,
align = "hv")
plot_row
pdf(height = 4, width = 4) plot_row dev.off()
pdf(height = 4, width = 4); plot_row; dev.off()
pdf(height = 4, width = 6); plot_row; dev.off()
pdf(height = 4, width = 8); plot_row; dev.off()
pdf(height = 3, width = 8); plot_row; dev.off()
pdf(height = 4, width = 10); plot_row; dev.off()
### ENRICHMENT PLOTS -----------------------------------------------------------
## Group: genetic vs. non-genetic
enrich1 <- df_match1 %>%
enrichmentPlot(., ont_hpo, forest = TRUE)
# manual labels
enrich1$plot$data$expcat_text <- NA
enrich1$plot$data[enrich1$plot$data$description == "Behavioral abnormality", ]$expcat_text <- "Behavioral abnormality"
enrich1$plot$data[enrich1$plot$data$description == "Complex febrile seizure", ]$expcat_text <- "Complex febrile seizure"
enrich1$plot$data[enrich1$plot$data$description == "Falls", ]$expcat_text <- "Falls"
enrich1$plot$data[enrich1$plot$data$description == "Seizure", ]$expcat_text <- "Seizure"
enrich1$plot <- enrich1$plot +
coord_fixed(xlim = c(0, .5), ylim = c(0, .5)) +
scale_x_continuous( breaks=pretty_breaks()) +
scale_y_continuous( breaks=pretty_breaks()) +
ggtitle("Genetic vs. Non-Genetic") +
theme(plot.title = element_text(hjust = 0.5, size = 18))
enrich1$plot
enrich1$plot <- enrich1$plot +
coord_fixed(xlim = c(0, .3), ylim = c(0, .3)) +
scale_x_continuous( breaks=pretty_breaks()) +
scale_y_continuous( breaks=pretty_breaks()) +
ggtitle("Genetic vs. Non-Genetic") +
theme(plot.title = element_text(hjust = 0.5, size = 18))
enrich1$plot
enrich1$plot <- enrich1$plot +
coord_fixed(xlim = c(0, .2), ylim = c(0, .2)) +
scale_x_continuous( breaks=pretty_breaks()) +
scale_y_continuous( breaks=pretty_breaks()) +
ggtitle("Genetic vs. Non-Genetic") +
theme(plot.title = element_text(hjust = 0.5, size = 18))
enrich1$plot
view(enrich1$plot$data)
# manual labels
enrich1$plot$data$expcat_text <- NA
enrich1$plot$data[enrich1$plot$data$description == "Behavioral abnormality", ]$expcat_text <- "Behavioral abnormality"
enrich1$plot$data[enrich1$plot$data$description == "Complex febrile seizure", ]$expcat_text <- "Complex febrile seizure"
enrich1$plot$data[enrich1$plot$data$description == "Falls", ]$expcat_text <- "Falls"
enrich1$plot$data[enrich1$plot$data$description == "Seizure", ]$expcat_text <- "Seizure"
enrich1$plot$data[enrich1$plot$data$description == "Abnormality of the cardiovascular system", ]$expcat_text <- "Abnormality of the cardiovascular system"
enrich1$plot <- enrich1$plot +
coord_fixed(xlim = c(0, .2), ylim = c(0, .2)) +
scale_x_continuous( breaks=pretty_breaks()) +
scale_y_continuous( breaks=pretty_breaks()) +
theme(plot.title = element_text(hjust = 0.5, size = 18))
enrich1$plot
pdf(height = 4, width = 4); enrich1$plot; dev.off()
pdf(height = 4, width = 4); enrich1$plot + ggtitle(""); dev.off()
### OTHER SUB-ANALYSIS ---------------------------------------------------------
## For HPO OR plot, find the terms that make up geniturourinary system abnormality
# define descendants
vec_desc <- get_descendants(ont_hpo, "HP:0001250")
df_desc <- df_match1 %>%
## remove TSC patients, to see if association remains strong; optional
# filter(PatientId %nin% df_tsc$PatientID) %>%
# filter cases by those containing descendant terms
filter(term %in% vec_desc) %>%
filter(group == TRUE) %>%
group_by(term) %>%
count(sort = TRUE) %>%
# get descriptions and ic
left_join(desc_map, by = "term") %>%
left_join(df_ic, by = "term") %>%
ungroup() %>%
# get pvalue for each term, only keep if it's independently significant
left_join(enrich1$data[, c("term", "pvalue")], by = "term") %>%
filter(pvalue < 0.05) %>%
# sort by IC
slice_max(n, prop = 0.9) %>%
arrange(desc(ic))
# reduce to minimal set
vec_min <- minimal_set(ont_hpo, df_desc$term)
df_desc <- df_desc[df_desc$term %in% vec_min, ]
# restrict subgraph by propagating back up from our minimal set
vec_desc <- propagate_relations(ont_hpo, df_desc$term, "parents") %>% unique()
# make igraph, convert to bn
librarian::shelf(igraph)
parents <- ont_hpo$parents
self <- rep(names(parents), lengths(parents))
g <- igraph::make_graph(rbind(unlist(parents), self))
bng <- as.bn(g)
# generate HPO subgraph of node of interest
arcs <- data.frame(bng$arcs)
arcs <- arcs[arcs$X1 %in% vec_desc & arcs$X2 %in% vec_desc, ]
colnames(arcs) <- c("from", "to")
graph_hpo <- empty.graph(vec_desc)
arcs(graph_hpo) <- arcs
# revert to igraph and format graph
g2 <- as.igraph(graph_hpo)
V(g2)$label <- NA
V(g2)[vec_min]$label <- rep(LETTERS)[1:length(V(g2)[vec_min]$label)]
V(g2)$color <- "gray"
V(g2)[vec_min]$color <- "red"
V(g2)$size <- 8
vec_size <- -log10(df_desc$pvalue)
vec_size[vec_size < 7] <- 8
V(g2)[vec_min]$size <- vec_size
E(g2)$arrow.mode <- 2
# use ggplotify to get a grob-able object
pqg <- as.ggplot(expression(plot(g2,
vertex.frame.color = "black",
vertex.label.color = "white",
vertex.label.family = "Helvetica",
vertex.label.font = 1,
vertex.label.cex = .9,
edge.arrow.size = .5,
layout = layout_as_tree))) # Reingold-Tilford
pqg
### OTHER SUB-ANALYSIS ---------------------------------------------------------
## For HPO OR plot, find the terms that make up geniturourinary system abnormality
# define descendants
vec_desc <- get_descendants(ont_hpo, "HP:0001250")
### OTHER SUB-ANALYSIS ---------------------------------------------------------
## For HPO OR plot, find the terms that make up geniturourinary system abnormality
# define descendants
vec_desc <- get_descendants(ont_hpo, "HP:0012638")
df_desc <- df_match1 %>%
## remove TSC patients, to see if association remains strong; optional
# filter(PatientId %nin% df_tsc$PatientID) %>%
# filter cases by those containing descendant terms
filter(term %in% vec_desc) %>%
filter(group == TRUE) %>%
group_by(term) %>%
count(sort = TRUE) %>%
# get descriptions and ic
left_join(desc_map, by = "term") %>%
left_join(df_ic, by = "term") %>%
ungroup() %>%
# get pvalue for each term, only keep if it's independently significant
left_join(enrich1$data[, c("term", "pvalue")], by = "term") %>%
filter(pvalue < 0.05) %>%
# sort by IC
slice_max(n, prop = 0.9) %>%
arrange(desc(ic))
# reduce to minimal set
vec_min <- minimal_set(ont_hpo, df_desc$term)
df_desc <- df_desc[df_desc$term %in% vec_min, ]
# restrict subgraph by propagating back up from our minimal set
vec_desc <- propagate_relations(ont_hpo, df_desc$term, "parents") %>% unique()
# make igraph, convert to bn
librarian::shelf(igraph)
parents <- ont_hpo$parents
self <- rep(names(parents), lengths(parents))
g <- igraph::make_graph(rbind(unlist(parents), self))
bng <- as.bn(g)
# generate HPO subgraph of node of interest
arcs <- data.frame(bng$arcs)
arcs <- arcs[arcs$X1 %in% vec_desc & arcs$X2 %in% vec_desc, ]
colnames(arcs) <- c("from", "to")
graph_hpo <- empty.graph(vec_desc)
arcs(graph_hpo) <- arcs
# revert to igraph and format graph
g2 <- as.igraph(graph_hpo)
V(g2)$label <- NA
V(g2)[vec_min]$label <- rep(LETTERS)[1:length(V(g2)[vec_min]$label)]
V(g2)$color <- "gray"
V(g2)[vec_min]$color <- "red"
V(g2)$size <- 8
vec_size <- -log10(df_desc$pvalue)
vec_size[vec_size < 7] <- 8
V(g2)[vec_min]$size <- vec_size
E(g2)$arrow.mode <- 2
# use ggplotify to get a grob-able object
pqg <- as.ggplot(expression(plot(g2,
vertex.frame.color = "black",
vertex.label.color = "white",
vertex.label.family = "Helvetica",
vertex.label.font = 1,
vertex.label.cex = .9,
edge.arrow.size = .5,
layout = layout_as_tree))) # Reingold-Tilford
pqg
vec_size
vec_size <- vec_size/4
V(g2)[vec_min]$size <- vec_size
E(g2)$arrow.mode <- 2
# use ggplotify to get a grob-able object
pqg <- as.ggplot(expression(plot(g2,
vertex.frame.color = "black",
vertex.label.color = "white",
vertex.label.family = "Helvetica",
vertex.label.font = 1,
vertex.label.cex = .9,
edge.arrow.size = .5,
layout = layout_as_tree))) # Reingold-Tilford
pqg
vec_size
vec_size[vec_size < 7] <- 8
V(g2)[vec_min]$size <- vec_size
E(g2)$arrow.mode <- 2
# use ggplotify to get a grob-able object
pqg <- as.ggplot(expression(plot(g2,
vertex.frame.color = "black",
vertex.label.color = "white",
vertex.label.family = "Helvetica",
vertex.label.font = 1,
vertex.label.cex = .9,
edge.arrow.size = .5,
layout = layout_as_tree))) # Reingold-Tilford
pqg
pqg <- pqg +
theme(plot.margin = unit(c(-50, -20, -50, -50), "pt"))
pqg
pdf(height = 8, width = 8); pqg; dev.off()
pdf(height = 4, width = 4); pqg; dev.off()
## p1: flag plot of encounters over age
p1 <- df %>%
# optional: subset to matched cohort
filter(PatientId %in% df_match1$PatientId) %>%
summarise(lower = min(ContactAge),
upper = max(ContactAge),
p = mean(ContactAge)) %>%
ggplot(aes(x = p, xmin = lower, xmax = upper,
y = reorder(PatientId, upper))) +
geom_linerange(size = 0.1) +
ylab("Individuals") +
xlab("Age at encounter (years)") +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Dark2") +
coord_cartesian(xlim = c(0, 35), expand = FALSE) +
theme_classic() +
theme(axis.ticks.y = element_blank(),
axis.text.y = element_blank())
# stats of length of follow-up
stats_followup <- p1$data %>%
# optional: subset to matched cohort
filter(PatientId %in% df_match1$PatientId) %>%
mutate(dur = upper-lower) %>%
summarize(mean = mean(dur), median = median(dur),
sd = sd(dur), min = min(dur), max = max(dur),
iqr = IQR(dur))
stats_followup
tmp <- df_match1 %>%
distinct(PatientId, group)
table(tmp$group)
225*7.61
V(g2)[vec_min]$label
vec_min
graph_hpo
arcs
[1:length(V(g2)[vec_min]$label)]
vec_min
tibble(term = vec_min) %>% left_join(desc_map)
save.image("~/Desktop/Slide_Dravet.RData")
