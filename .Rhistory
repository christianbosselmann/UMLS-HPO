#' @return res list of data.frame and plot object
enrichmentPlot <- function(data,
ontology){
# object to return
res <- list()
# read term names from ontologyIndex object
desc_map <- tibble(term = ontology$id,
description = ontology$name)
# reshape to dataframe of terms and columns Y/N for term count in group/!group
df_group <- data %>%
group_by(term) %>%
count(group) %>%
pivot_wider(names_from = group, values_from = n) %>%
rename(N = `FALSE`, Y = `TRUE`) %>%
replace(is.na(.), 0)
# add in term descriptions for graph
df_group <- left_join(df_group, desc_map, by = "term")
# data characteristics
Y_tot <- max(df_group$Y) # total number of observations in group
N_tot <- max(df_group$N) # total number of observations in !group
n_tests <- nrow(df_group) # number of multiple tests
# setup plot
concept_vis_input.df3 <- df_group %>%
mutate(Y_out = Y_tot-Y,
N_out = N_tot-N) %>%
mutate(pvalue = fish_test_it(Y,Y_out,N,N_out,"pvalue"),
odds = fish_test_it(Y,Y_out,N,N_out,"odds"),
freq1 = Y/Y_tot,
freq2 = N/N_tot,
color_sig = ifelse(p.adjust(pvalue, "bonferroni") < 0.05, "<", ">"),
size_sel = -log10(pvalue)*4) %>%
filter(freq1 > 0.05 | freq2 > 0.05) # minimum term frequency filter
res$data <- concept_vis_input.df3
max_freq <- c(concept_vis_input.df3$freq1, concept_vis_input.df3$freq2) %>% max()
# n of top p-values to label
top_sig <- head(sort(concept_vis_input.df3$pvalue, decreasing = FALSE), n = 15)
# plot
res$plot <- concept_vis_input.df3 %>%
mutate(expcat_text = ifelse(pvalue %in% top_sig, description, NA)) %>%
ggplot(aes(x = freq2, y = freq1, color = color_sig)) +
geom_point(aes(size = size_sel), show.legend = FALSE) +
theme_classic(base_size = 20) +
# coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
coord_cartesian(xlim = c(0, max_freq), ylim = c(0, max_freq)) +
geom_abline(slope = 1, linetype = "dashed") +
scale_color_manual(values = c("red", "black")) +
labs(y = "Case",
x = "Control") +
geom_label_repel(aes(label = expcat_text), color = "black", max.overlaps = 8, size = 3, force_pull = 0.4) +
theme(axis.text = element_text(color = "black"),
axis.line = element_line(color = "black")) +
guides(color = "none")
return(res)
}
### visualize kernel matrix
#' @param K kernel matrix to be visualized
#' @param hc.order boolean, see hc.order attribute of ggcorrplot fn
#' @return ggplot2 object
kernelVisualization <- function(K, hc.order = TRUE){
library(ggplot2)
library(ggcorrplot)
ggcorrplot(K,
hc.order = hc.order,
hc.method = "average",
outline.color = NA,
legend.title = "  r",
colors = c("#6D9EC1", "white", "#E46726"))
}
### negate in
`%nin%` = Negate(`%in%`)
### normalize kernel matrix
# cf. Kernel Methods for Pattern Analysis, Algorithm 5.1
#' @param K kernel matrix to be normalized
#' @return normalized kernel matrix
kernelNormalisation <- function(K){
# min_eigenvalue <- min(eigen(K)$values)
# K <- sqrt(diag(K) + min_eigenvalue)
D <- diag(1/sqrt(diag(K)))
K <- D %*% K %*% D
return(K)
}
### center in feature space
# cf. Kernel Methods for Pattern Analysis, Algorithm 5.3
#' @param K kernel matrix to be centered
#' @return kernel matrix centered in feature space
kernelCentering <- function(K){
ell <- dim(K)[1]
D <- colSums(K)/ell # row vector storing the column averages of K
E <- sum(D)/ell # average of all the entries of K
J <- matrix(1, ell, 1) %*% D
Jt <- Conj(t(J)) # complex conjugate transpose of J
K <- K - J - Jt + E * matrix(1, ell, ell)
}
### check if matrix is symmetric and psd
#' @param K kernel matrix to be checked
#' @return prints matrix properties to console
#' adapted from base and matrixcalc
kernelCheck <- function(K, tol = 1e-08){
if(!isSymmetric(K)){stop("Argument is not a symmetric matrix.")}
if(isSymmetric(K)){print("Argument is a symmetric matrix.")}
ev <- eigen(K)[[1]]
n <- nrow(K)
for (i in 1:n) {
if (abs(ev[i]) < tol) {
ev[i] <- 0
}
}
if (any(ev < 0)) {
stop("Argument is not a psd matrix.")
}
print("Argument is a psd matrix.")
}
### standard kernel preprocessing
#' @param K kernel matrix to be normalized and centered
#' @return kernel matrix
kernelPreparation <- function(K){
K <- kernelNormalisation(K)
K <- kernelCentering(K)
K <- round(K, 10)
return(K)
}
### integrated pairwise phenotypic similarity
#' @params term_list list of character vectors of HPO terms, where each element in the list is a patient or variant
#' @params ontology ontologyIndex object
#' @params method similarity measure, choice of c("jaccard", "lin", "resnik", "euclidean", "cosine")
#' @returns mat_pheno a phenotypic similarity kernel matrix (psd)
pairwiseSimilarity <- function(term_list, ontology, method){
# pkg
library(ontologyIndex)
library(ontologySimilarity)
library(proxy)
library(klic)
library(tidyverse)
# check method
if (method %nin% c("jaccard", "lin", "resnik", "euclidean", "cosine")) stop("Invalid method.")
if (method %in% c("jaccard", "euclidean", "cosine")) {
# get pairwise phenotypic similarity: jaccard
ls_prop <- lapply(term_list,
propagate_relations,
ontology = ontology,
relations = "parents")
df_prop <- ls_prop %>%
map_dfr(~ .x %>% as_tibble(), .id = "name")
df_prop <- reshape2::dcast(df_prop, name ~ value, length)
df_prop <- df_prop[,-1] # remove id col
df_prop[df_prop > 0] <- 1 # enforce binary
mat_pheno <- proxy::simil(x = df_prop,
method = method) # "jaccard", "euclidean", "cosine"
mat_pheno <- as.matrix(mat_pheno)
diag(mat_pheno) <- 1
}else{
# get pairwise phenotypic similarity: lin/resnik
ic <- get_term_info_content(ontology, term_list, patch_missing = FALSE)
mat_pheno <- get_sim_grid(ontology = ontology,
information_content = ic,
term_sim_method = method, # i.e. "lin", "resnik"
term_sets = term_list)
mat_pheno <- klic::spectrumShift(mat_pheno, coeff = 1.2) # nearest psd
}
# sanity check
kernelCheck(mat_pheno)
# return phenotypic kernel matrix
return(mat_pheno)
}
#' this function takes a dataframe of variables for bnlearn and
#' removes constant and/or perfectly correlated columns
#' importantly, perfectly correlated columns are "grouped"
#' the colnames of removed columns are preserved
#' @param vars df of binary variables
#' @param remove_constants boolean; if TRUE, remove constant columns
#' @param remove_correlated boolean; if TRUE, remove/grouped corr. columns
#' @param threshold for remove_correlated, the correlation of threshold
#' @param as_factor boolean; if TRUE, coerce variables to factors for BDs score
preprocessVariables <- function(vars,
remove_constants = TRUE,
remove_correlated = TRUE,
threshold = 0.95,
as_factor = TRUE){
# pkg
library(igraph)
library(bnlearn)
if(remove_constants){
vars <- vars[sapply(vars, function(x) length(unique(na.omit(x)))) > 1]
}
if(remove_correlated){
df_cor <- cor(as.matrix(vars), method = "pearson")
var_cor <- df_cor*lower.tri(df_cor)
df_cor <- which(df_cor >= threshold, arr.ind = TRUE)
graph_cor <- igraph::graph.data.frame(df_cor, directed = FALSE)
groups_cor <- split(unique(as.vector(df_cor)),
clusters(graph_cor)$membership)
groups_cor <- lapply(groups_cor, function(x) {rownames(var_cor)[x]})
for (i in 1:length(groups_cor)){
# keep the first element, discard the rest but keep their HPO IDs in colname
str_cols <- groups_cor[[i]]
to_keep <- str_cols[1]
to_drop <- str_cols[-1]
if(is_empty(to_drop)) next
grp_name <- paste(str_cols, collapse = " ")
vars <- vars[, -which(names(vars) %in% to_drop)]
names(vars)[names(vars) == to_keep] <- grp_name
}
}
if(as_factor){
dim <- ncol(vars)
vars[,1:dim] <- lapply(vars[,1:dim], function(x) factor(x, level = c(0, 1)))
}
return(vars)
}
# Fisher's test function from Sara
fish_test_it <- function(g1,g1_out,g2,g2_out,label){
pvalue <- c()
odds <- c()
for(i in 1:length(g1)){
fish_out <- matrix(c(g1[i],g1_out[i],g2[i],g2_out[i]),ncol =2) %>% fisher.test()
pvalue <- c(pvalue,fish_out$p.value)
odds <- c(odds,fish_out$estimate)
}
if(label == "pvalue"){
return(pvalue)
}else{
return(odds)
}
}
# run fn
res <- enrichmentPlot(df_map, ont_hpo)
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("Tmp plot") +
theme(plot.title = element_text(hjust = 0.5))
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("Temporal vs extratemporal lobectomy") +
theme(plot.title = element_text(hjust = 0.5))
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("Temporal vs. extratemporal lobectomy") +
theme(plot.title = element_text(hjust = 0.5, size = 20))
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("Temporal vs. extratemporal lobectomy") +
theme(plot.title = element_text(hjust = 0.5, size = 15))
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("Temporal vs. extratemporal lobectomy") +
theme(plot.title = element_text(hjust = 0.5))
res$plot +
coord_fixed(xlim = c(0, 0.25), ylim = c(0, 0.25)) +
ggtitle("TLE vs. ExTLE") +
theme(plot.title = element_text(hjust = 0.5))
head(df_map)
df_map %>%
filter(group = T) %>%
nrow()
df_map %>%
filter(group == T) %>%
nrow()
df_map %>%
filter(group == F) %>%
nrow()
# longitudinal genetic data
# pkg
library(librarian)
librarian::shelf(tidyverse,
ggrepel,
ontologyIndex,
data.table,
scales,
finalfit,
kable,
kableExtra)
# helper fn
source("func.R")
### ONTOLOGY ------------------------------------------------------------------
# load ontology
ont_hpo <- get_ontology("hp.obo.txt",
propagate_relationships = "is_a",
extract_tags = "everything")
# prepare UMLS-HPO map
hpo_map <- lapply(ont_hpo$xref, function(x){
x <- x[x %like% "UMLS:"]
x <- sub('.*\\:', '', x)
})
hpo_map <- enframe(hpo_map) %>%
unnest(value) %>%
rename(ConceptID = value)
desc_map <- tibble(term = ont_hpo$id,
description = ont_hpo$name)
# prepare propagation map
prop_map <- ont_hpo$ancestors %>%
enframe() %>%
rename(term = name, prop_terms = value)
### DATA ----------------------------------------------------------------------
# data: all encounters per patient, ages 0-6, grouped by gene positive / negative
df_raw <- read_csv("~/Desktop/CCF/EMR cohort study/Surgery cohort/data/longitudinal_genetic.csv")
# only keep columns we are interested in
df <- df_raw %>%
select(PatientId, # patient ID
ConceptID, # UMLS code for encounter
GENEPOS_comb, # binary vector: non-genetic vs likely genetic patient
ContactAge, # relative age at encounter
ProcAge # age at epilepsy CPT
)
### CONSTANTS -----------------------------------------------------------------
n_patients <- length(unique(df$PatientId))
max_age <- max(df$ContactAge)
### MISSING DATA --------------------------------------------------------------
# order by PatientId
# check for NA in ContactAge
# replace NA with previous value
# then drop missing rows
df <- df %>%
group_by(PatientId) %>%
arrange(desc(ContactAge)) %>%
fill(ContactAge, .direction = c("up")) %>%
na.omit
### SUMMARY STATS -------------------------------------------------------------
# demographic table
df_person <- df_raw %>%
group_by(PatientId, DateOfBirth, Gender, Ethnicity, GENEPOS, GENEPOS_comb, ProcAge) %>%
summarize(max_age = max(ContactAge, na.rm = TRUE),
min_age = min(ContactAge, na.rm = TRUE),
median_age = median(ContactAge, na.rm = TRUE))
# TODO fix gender/ethnicity labels once we have UMLS access
ls_col = c("Gender", "Ethnicity", "ProcAge", "min_age", "median_age", "max_age")
tbl1 <- df_person %>%
mutate(Gender = recode(Gender,
"C0086582" = "Male",
"C0086287" = "Female")) %>%
mutate(Ethnicity = recode(Ethnicity,
"C1518424" = "Not Hispanic or Latino",
"C1549625" = "Unknown",
"C5441846" = "Hispanic or Latino",
"None" = "Unknown")) %>%
summary_factorlist("GENEPOS_comb", ls_col, p = TRUE, na_include = TRUE)  %>%
knitr::kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
save_kable("out/longitudinal_demographic_tbl.png", density = 900, zoom = 1.5)
# flag plot of encounters over age
df %>%
summarise(lower = min(ContactAge),
upper = max(ContactAge),
p = mean(ContactAge)) %>%
ggplot(aes(x = p, xmin = lower, xmax = upper,
y = reorder(PatientId, upper))) +
geom_linerange(size = 0.1) +
ylab("Individuals") +
xlab("Age at encounter") +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Dark2") +
coord_cartesian(xlim = c(0, 35), expand = FALSE) +
theme_classic() +
theme(axis.ticks.y = element_blank(),
axis.text.y = element_blank())
# density plot of encounters over time
df_filtered <- df %>%
filter (PatientId %in% df_person$PatientId)
ggpubr::ggdensity(df_filtered, x = "ContactAge",
add = "mean", rug = FALSE,
fill = "GENEPOS_comb", palette = c("#00AFBB", "#E7B800"))
# raincloud plot of age at diagnosis (ProcAge)
devtools::source_gist("2a1bb0133ff568cbe28d", filename = "geom_flat_violin.R")
pval <- data.frame(
group1 = "N",
group2 = "Y",
label = t.test(df_filtered$ProcAge ~ df_filtered$GENEPOS_comb, paired = FALSE)$p.value,
y.position = 6
)
df_filtered %>%
ggplot(aes(x = GENEPOS_comb, y = ProcAge, fill = GENEPOS_comb)) +
geom_flat_violin(position = position_nudge(x = .1, y = 0), alpha = .8) +
guides(fill = "none", color = "none") +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Dark2") +
xlab("Group") +
ylab("Age at diagnosis") +
theme_classic() +
coord_cartesian(xlim = c(1.5, 2)) +
geom_boxplot(width = .1, show.legend = FALSE, outlier.shape = NA, alpha = 0.5) +
ggpubr::stat_compare_means(aes(label = paste0("p = ", after_stat(p.format))),
label.x = 1.5, label.y = 6)
# age at encounter
ggplot(data = df_filtered, aes(x = GENEPOS_comb, y = ContactAge, fill = GENEPOS_comb)) +
geom_flat_violin(position = position_nudge(x = .1, y = 0), alpha = .8) +
guides(fill = "none", color = "none") +
scale_color_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Dark2") +
xlab("Group") +
ylab("Age at encounter") +
theme_classic() +
coord_cartesian(xlim = c(1.5, 2)) +
## point cloud
# geom_point(aes(color = GENEPOS_comb),
#            position = position_jitter(width = 0.15, seed = 1),
#            size = .1, alpha = 0.01) +
geom_boxplot(width = .1, show.legend = FALSE, outlier.shape = NA, alpha = 0.5) +
ggpubr::stat_compare_means(aes(label = paste0("p = ", after_stat(p.format))),
label.x = 1.5, label.y = 6)
### HPO ANALYSIS --------------------------------------------------------------
# create age bins
df_binned <- df %>%
ungroup() %>%
mutate(bin = cut_number(ContactAge, n = 10))
# hacky way to get numeric breaks for histogram
breaks_binned <- levels(df_binned$bin) %>%
sapply(., function(x) {gsub("\\,", " ", x)}) %>%
parse_number()
breaks_binned <- c(breaks_binned, max(df_binned$ContactAge))
# split into age bins and print unique concepts per bin as sanity-check
ls_binned <- df_binned %>%
split(.$bin)
lapply(ls_binned, function(x) length(unique(x$ConceptID))) %>%
unlist() %>%
tibble(mean = mean(.), sd = sd(.), min = min(.), max = max(.)) %>%
select(-.) %>%
tail(1) %>%
print()
# for each bin, map to HPO terms, then map to propagated HPO terms
ls_mapped <- list()
for(i in 1:length(ls_binned)){
ls_mapped[[i]] <- left_join(ls_binned[[i]], hpo_map, by = "ConceptID") %>%
rename(term = name) %>%
na.omit()
ls_mapped[[i]] <- left_join(ls_mapped[[i]], prop_map, by = "term")
}
# get information content (IC)
ls_terms <- ls_mapped %>%
rbindlist() %>%
select(PatientId, prop_terms) %>%
.$prop_terms %>%
unlist() %>%
unique()
ic <- get_term_info_content(ontology = ont_hpo, term_sets = ls_terms)
ic <- tibble(term = names(ic),
ic = ic)
# reshape each bin to unique HPO terms
# count of gene positive (Y) and negative (N) patients
# run Fisher's test
# get n most significant terms per bin
# TODO consider whether to do distinct patient-term pairs per bin
ls_pvalues <- list()
for(i in 1:length(ls_mapped)){
df_group <- ls_mapped[[i]] %>%
select(PatientId, GENEPOS_comb, prop_terms) %>%
unnest(cols = c(prop_terms)) %>%
group_by(prop_terms, GENEPOS_comb) %>%
count(prop_terms) %>%
pivot_wider(names_from = GENEPOS_comb, values_from = n) %>%
replace(is.na(.), 0) %>%
rename(term = prop_terms)
# merge in description
df_group <- left_join(df_group, desc_map, by = "term")
# df_group can also be used for enrichment plots
df_group <- df_group %>%
mutate(Y_out = max(df_group$Y)-Y,
N_out = max(df_group$N)-N) %>%
mutate(pvalue = fish_test_it(Y, Y_out, N, N_out, "pvalue"),
odds = fish_test_it(Y, Y_out, N, N_out, "odds"),
freq1 = Y/max(df_group$Y),
freq2 = N/max(df_group$N),
color_sig = ifelse(p.adjust(pvalue, "holm") < 0.05, "<", ">"),
size_sel = -log10(pvalue)*4)
# get n best p-values for each bin for longitudinal plot
df_group <- df_group %>%
ungroup() %>%
select(term, description, pvalue) %>%
slice_min(order_by = pvalue, n = 8, with_ties = FALSE) # non-trivial to choose
# # filter: by IC
# df_group <- df_group %>%
#   left_join(ic, by = "term") %>%
#   slice_max(order_by = ic, n = 2, with_ties = FALSE)
# filter: by ancestors
min_set <- ontologyIndex::minimal_set(ont_hpo, df_group$term)
df_group <- df_group[df_group$term %in% min_set, ]
# return
ls_pvalues[[i]] <- df_group
}
# fix bin to correspond to mean age of bin for graph
seq <- seq(1, length(breaks_binned), 1)
breaks_mean <- sapply(seq, function(i) {mean(breaks_binned[i:(i+1)])}) %>%
na.omit
# filter: for each term, keep only the bin with the highest p-value
names(ls_pvalues) <- breaks_mean
df_pvalues <- ls_pvalues %>%
rbindlist(idcol = "bin") %>%
mutate(bin = as.numeric(bin))
df_pvalues <- df_pvalues %>%
group_by(term) %>%
slice_min(order_by = pvalue, n = 1)
# point plot: log10(pvalue) over age bins
palette <- colorRampPalette(RColorBrewer::brewer.pal(9, name = 'RdBu'))(length(breaks_mean))
df_pvalues %>%
ggplot(aes(x = bin, y = -log10(pvalue), fill = factor(bin, levels = breaks_mean))) +
geom_point() +
geom_label_repel(aes(label = description), size = 3,
color = "black", max.overlaps = 10,
force_pull = 0.5) +
scale_fill_manual(values = palette,
name = "Mean age (years)",
breaks = breaks_mean,
labels = format(round(breaks_mean, 3), nsmall = 1),
guide = guide_legend(override.aes = list(label = ""))) +
theme_classic() +
xlab("Age (years)")
# histogram: very simple way to show bin distribution
df_binned %>%
ggplot(aes(x = ContactAge, fill = bin)) +
geom_histogram(breaks = breaks_binned) +
xlab("Age at contact") +
ylab("") +
labs(fill = "Age bins") +
theme_classic()
