distinct(PatientId, AgePrescription, ORD_MODE_DESC)
df_nstays <- df_stays %>%
mutate(ORD_MODE_DESC = factor(ORD_MODE_DESC, levels = c("INPATIENT", "OUTPATIENT"))) %>%
group_by(PatientId, .drop = FALSE) %>%
count(ORD_MODE_DESC)
# find PatientIds who had multiple inpatient encounters
df_inpatient <- df_nstays %>%
filter(ORD_MODE_DESC == "INPATIENT" & n > 1) %>%
mutate(hasInpatient = TRUE)
# stats: are Confirmed genetic patients more likely to be seen inpatient?
map_match <- df_match1 %>%
distinct(PatientId, group)
p_inpatient <- df_inpatient %>%
left_join(map_match) %>%
na.omit %>%
ungroup() %>%
summarize(pval = t.test(n ~ group)$p.value)
stats_inpatient <- df_inpatient %>%
left_join(map_match) %>%
na.omit %>%
group_by(group) %>%
summarize(mean = mean(n), median = median(n),
sd = sd(n),
min = min(n), max = max(n),
n = n_distinct(PatientId))
### ER VISITS -----------------------------------------------------------------
## data: ER admissions for all patients
df_er <- readxl::read_excel("~/Desktop/CCF/EMR cohort study/Surgery cohort/data/ER_Visits.xlsx")
# get group label
df_er <- df_er %>%
rename(PatientId = PatientID) %>%
left_join(map_match) %>%
na.omit
# subset to strict cohort criteria
df_er <- df_er %>%
filter(PatientId %in% df$PatientId)
# count admissions for each patient
p_er <- df_er %>%
add_count(PatientId, AdmissionType) %>%
summarize(pval = t.test(n ~ group)$p.value)
stats_er <- df_er %>%
group_by(group) %>%
add_count(PatientId, AdmissionType) %>%
summarize(mean = mean(n), median = median(n),
sd = sd(n),
min = min(n), max = max(n),
n = n_distinct(PatientId))
df_er <- df_er %>%
group_by(group) %>%
add_count(PatientId, AdmissionType) %>%
distinct(PatientId, n)
### OTHER SUB-ANALYSIS ---------------------------------------------------------
## For HPO OR plot, find the terms that make up geniturourinary system abnormality
# define descendants
vec_desc <- get_descendants(ont_hpo, "HP:0000119")
df_desc <- df_match1 %>%
# filter cases by those containing descendant terms
filter(term %in% vec_desc) %>%
filter(group == TRUE) %>%
group_by(term) %>%
count(sort = TRUE) %>%
# get descriptions and ic
left_join(desc_map, by = "term") %>%
left_join(df_ic, by = "term") %>%
ungroup() %>%
# get pvalue for each term, only keep if it's independently significant
left_join(enrich1$data[, c("term", "pvalue")], by = "term") %>%
filter(pvalue < 0.05) %>%
# sort by IC
slice_max(n, prop = 0.9) %>%
arrange(desc(ic))
# reduce to minimal set
vec_min <- minimal_set(ont_hpo, df_desc$term)
df_desc <- df_desc[df_desc$term %in% vec_min, ]
# restrict subgraph by propagating back up from our minimal set
vec_desc <- propagate_relations(ont_hpo, df_desc$term, "parents") %>% unique()
# make igraph, convert to bn
librarian::shelf(igraph)
parents <- ont_hpo$parents
self <- rep(names(parents), lengths(parents))
g <- igraph::make_graph(rbind(unlist(parents), self))
bng <- as.bn(g)
# generate HPO subgraph of node of interest
arcs <- data.frame(bng$arcs)
arcs <- arcs[arcs$X1 %in% vec_desc & arcs$X2 %in% vec_desc, ]
colnames(arcs) <- c("from", "to")
graph_hpo <- empty.graph(vec_desc)
arcs(graph_hpo) <- arcs
# revert to igraph and format graph
g2 <- as.igraph(graph_hpo)
V(g2)$label <- NA
V(g2)[vec_min]$label <- rep(LETTERS)[1:length(V(g2)[vec_min]$label)]
V(g2)$color <- "gray"
V(g2)[vec_min]$color <- pal_val[[2]]
V(g2)$size <- 8
vec_size <- -log10(df_desc$pvalue)
vec_size[vec_size < 7] <- 8
V(g2)[vec_min]$size <- vec_size
E(g2)$arrow.mode <- 2
# use ggplotify to get a grob-able object
pqg <- as.ggplot(expression(plot(g2,
vertex.frame.color = "black",
vertex.label.color = "white",
vertex.label.family = "Helvetica",
vertex.label.font = 1,
vertex.label.cex = .9,
edge.arrow.size = .5,
layout = layout_as_tree))) # Reingold-Tilford
pqg <- pqg +
theme(plot.margin = unit(c(-50, -20, -50, -50), "pt"))
### EXPORT ---------------------------------------------------------------------
p2_3 <- cowplot::plot_grid(p2, p3, ncol = 1, labels = "", align = "hv")
pt1_2 <- cowplot::plot_grid(pt1, pt2, ncol = 1, labels = "", align = "hv")
FigSx <- cowplot::plot_grid(p2_3, p4, pt1_2, nrow = 1, labels = c("AUTO"), align = "v", axis = "b")
pdf(file = "FigSx.pdf",
width = 12,
height = 4)
FigSx
dev.off()
FigSy <- cowplot::plot_grid(enrich1$forest +
theme(plot.margin = margin(.5,0,.5,0, "cm")), # trbl
pqg,
enrich1$plot +
scale_color_manual(values = c(pal_val[[2]], "black")) +
ggtitle("") +
theme_set(theme_classic()) +
ylab("Frequency, genetic patient encounters") +
xlab("Frequency, non-genetic patients encounters") +
theme(plot.margin = margin(0,0,.5,0, "cm")),
# rel_widths = c(0.4, .2, .4),
nrow = 1, labels = "AUTO", align = "none")
pdf(file = "FigSy.pdf",
width = 12,
height = 4)
FigSy
dev.off()
FigSz <- cowplot::plot_grid(pheat1 + theme(legend.position = "none"),
p_asm,
nrow = 1, labels = "AUTO", align = "none")
pdf(file = "FigSz.pdf",
width = 12,
height = 8)
FigSz
dev.off()
### REPLICATION ANALYSIS -------------------------------------------------------
## save hypotheses (test, p-value, OR estimate) for cross-sectional phenotypes,
## longitudinal phenotypes, prescription data
write_csv(enrich1$data, "rep_cross-sectional_group2.csv")
write_csv(plong1f$plot$data, "rep_longitudinal_group2.csv")
write_csv(df_heatmap, "rep_medical_group2.csv")
plong1f$plot$data %>%
filter(description %like% "Osteoporosis") %>%
getCI()
plong1f$plot$data %>%
filter(description %like% "Renal insuff") %>%
getCI()
### UMLS-HPO ANALYSIS OF INDIVIDUALS WITH GENETIC EPILEPSY SYNDROMES -----------
## Replication
##
## Author: Christian Bosselmann, MD
##
## Date Created: 2023-06-19
##
## Copyright (c) Christian Bosselmann, 2023
## Email: bosselc@ccf.org
##
### ----------------------------------------------------------------------------
# this script analyzes the reproducibility of associations and their effect size between the two stages
### HEADER ---------------------------------------------------------------------
# gray-red 2-color palette
pal_rep <- c("#71706e", "#f01313")
### DATA -----------------------------------------------------------------------
## hypotheses for cross-sectional clinical characteristics, longitudinal
## clinical characteristics, and prescription patterns
ls_cs <- list(read_csv("rep_cross-sectional_group1.csv"),
read_csv("rep_cross-sectional_group2.csv")) %>%
rbindlist(idcol = "group")
ls_lg <- list(read_csv("rep_longitudinal_group1.csv"),
read_csv("rep_longitudinal_group2.csv")) %>%
rbindlist(idcol = "group")
ls_md <- list(read_csv("rep_medical_group1.csv"),
read_csv("rep_medical_group2.csv")) %>%
rbindlist(idcol = "group")
### ANALYSIS: CROSS-SECTIONAL --------------------------------------------------
## T1: How many significant hypotheses in stage 2 also occur in stage 1, with the same effect direction?
ls_cs_t1 <- ls_cs %>%
filter(pvalue < 0.05) %>%
mutate(direction = ifelse(odds <= 1, -1, 1)) %>%
select(group, term, direction)
# number of sig hypotheses in stage 1
n_cs_t1_1 <- nrow(ls_cs_t1[ls_cs_t1$group == "1", ])
# number of sig hypotheses in stage 2 that have the same direction
n_cs_t1_2 <- intersect(ls_cs_t1[ls_cs_t1$group == "1", -1], ls_cs_t1[ls_cs_t1$group == "2", -1]) %>%
nrow()
## T2: Median original and replication effect sizes
# convert effect size to r (which is 0,1 bounded and nicely interpretable)
# cf. https://easystats.github.io/effectsize/reference/d_to_r.html
ls_cs_t2 <- ls_cs %>%
mutate(effect = effectsize::oddsratio_to_r(odds, Y, N)) %>%
na.omit
# effect size estimates between stages
p_cs_t2 <- ls_cs_t2 %>%
group_by(group) %>%
summarize(mean = mean(effect), sd = sd(effect), median = median(effect))
# p-value: t-test to compare effect size estimates between stages
stats_cs_t2 <- ls_cs_t2 %>%
summarize(pval = t.test(effect ~ group)$p.value)
## T3: Percent original effect size within replication 95% CI
ls_cs_t3 <- ls_cs %>%
filter(group == "1") %>%
mutate(is_within = FALSE)
for(i in 1:nrow(ls_cs_t3)){
row_stage1 <- ls_cs[i ,]
row_stage2 <- ls_cs[ls_cs$term == row_stage1$term & ls_cs$group == "2", ]
# get OR 95% CI; fails for very small sample sizes; if so, skip
possibleError <- tryCatch(
expr = {
row_stage1 <- getCI(row_stage1)
row_stage2 <- getCI(row_stage2)
},
error = function(e){
e
}
)
if(inherits(possibleError, "error")) next
# check if OR of group 1 is within CI1 and CI2 of group 2
is_within <- (row_stage1$odds > row_stage2$CI1) & (row_stage1$odds < row_stage2$CI2)
# store in dataframe of just group 1 hypotheses
ls_cs_t3[i ,]$is_within <- is_within
}
stats_cs_t3 <- nrow(ls_cs_t3[ls_cs_t3$is_within == "TRUE", ])/nrow(ls_cs_t3[ls_cs_t3$is_within == "FALSE", ])
## PLOT
ls_cs_dfp <- ls_cs_t2 %>%
select(term, group, effect) %>%
pivot_wider(names_from = "group", values_from = "effect") %>%
# keep p-value
left_join(ls_cs_t3[ls_cs_t3$group == "1", ][ ,c("term", "pvalue")]) %>%
mutate(is_sig = ifelse(pvalue < 0.05, 1, 0)) %>%
mutate(is_sig = as.factor(is_sig))
ls_cs_p <- ls_cs_dfp %>%
ggplot(aes(x = `1`, y = `2`, color = is_sig)) +
geom_point() +
scale_x_continuous(limits = c(-.4, .4)) +
scale_y_continuous(limits = c(-.4, .4)) +
scale_color_manual(values = pal_rep) +
theme_classic() +
theme(legend.position = "none") +
coord_fixed() +
xlab("Stage 1 Effect Size\nCross-sectional phenotype") +
ylab("Stage 2 Effect Size\nCross-sectional phenotype") +
geom_smooth(method = lm, se = FALSE) +
stat_cor(method = "pearson",
geom = "label",
label.npc.y = 0.01,
label.x.npc = 0.01)
ls_cs_p <- ggExtra::ggMarginal(ls_cs_p,
type = "histogram",
groupFill = TRUE,
groupColour = TRUE)
### ANALYSIS: LONGITUDINAL --------------------------------------------------
## T1: How many significant hypotheses in stage 2 also occur in stage 1, with the same effect direction?
ls_lg_t1 <- ls_lg %>%
filter(pvalue < 0.05) %>%
mutate(direction = ifelse(odds <= 1, -1, 1)) %>%
select(group, bin, term, direction)
# number of sig hypotheses in stage 1
n_lg_t1_1 <- nrow(ls_lg_t1[ls_lg_t1$group == "1", ])
# number of sig hypotheses in stage 2 that have the same direction
n_lg_t1_2 <- intersect(ls_lg_t1[ls_lg_t1$group == "1", -1], ls_lg_t1[ls_lg_t1$group == "2", -1]) %>%
nrow()
## T2: Median original and replication effect sizes
# convert effect size to r (which is 0,1 bounded and nicely interpretable)
# cf. https://easystats.github.io/effectsize/reference/d_to_r.html
ls_lg_t2 <- ls_lg %>%
mutate(effect = effectsize::oddsratio_to_r(odds, Y, N)) %>%
na.omit
# effect size estimates between stages
p_lg_t2 <- ls_lg_t2 %>%
group_by(group) %>%
summarize(mean = mean(effect), sd = sd(effect), median = median(effect))
# p-value: t-test to compare effect size estimates between stages
stats_lg_t2 <- ls_lg_t2 %>%
summarize(pval = t.test(effect ~ group)$p.value)
## T3: Percent original effect size within replication 95% CI
ls_lg_t3 <- ls_lg %>%
filter(group == "1") %>%
mutate(is_within = FALSE)
for(i in 1:nrow(ls_lg_t3)){
row_stage1 <- ls_lg[i ,]
row_stage2 <- ls_lg[ls_lg$term == row_stage1$term &
ls_lg$group == "2" &
ls_lg$bin == row_stage1$bin, ]
# get OR 95% CI; fails for very small sample sizes; if so, skip
possibleError <- tryCatch(
expr = {
row_stage1 <- getCI(row_stage1)
row_stage2 <- getCI(row_stage2)
},
error = function(e){
e
}
)
if(inherits(possibleError, "error")) next
# check if OR of group 1 is within CI1 and CI2 of group 2
is_within <- (row_stage1$odds > row_stage2$CI1) & (row_stage1$odds < row_stage2$CI2)
# store in dataframe of just group 1 hypotheses
ls_lg_t3[i ,]$is_within <- is_within
}
stats_lg_t3 <- nrow(ls_lg_t3[ls_lg_t3$is_within == "TRUE", ])/nrow(ls_lg_t3[ls_lg_t3$is_within == "FALSE", ])
## PLOT
ls_lg_dfp <- ls_lg_t2 %>%
select(term, bin, group, effect) %>%
pivot_wider(names_from = "group", values_from = "effect") %>%
# keep p-value
left_join(ls_lg_t3[ls_lg_t3$group == "1", ][ ,c("term", "bin", "pvalue")]) %>%
mutate(is_sig = ifelse(pvalue < 0.05, 1, 0)) %>%
mutate(is_sig = as.factor(is_sig))
ls_lg_p <- ls_lg_dfp %>%
ggplot(aes(x = `1`, y = `2`, color = is_sig)) +
geom_point() +
scale_x_continuous(limits = c(-.4, .4)) +
scale_y_continuous(limits = c(-.4, .4)) +
scale_color_manual(values = pal_rep) +
theme_classic() +
theme(legend.position = "none") +
coord_fixed() +
xlab("Stage 1 Effect Size\nLongitudinal phenotype") +
ylab("Stage 2 Effect Size\nLongitudinal phenotype") +
geom_smooth(method = lm, se = FALSE) +
stat_cor(method = "pearson",
geom = "label",
label.npc.y = 0.01,
label.x.npc = 0.01)
ls_lg_p <- ggExtra::ggMarginal(ls_lg_p,
type = "histogram",
groupFill = TRUE,
groupColour = TRUE)
### ANALYSIS: MEDICAL ----------------------------------------------------------
# preprocessing: recover odds ratio, which was previously removed for plot
tmp <- getCI(ls_md)[ ,15:17]
ls_md[ ,9:11] <- tmp
## T1: How many significant hypotheses in stage 2 also occur in stage 1, with the same effect direction?
ls_md_t1 <- ls_md %>%
filter(P < 0.05) %>%
mutate(direction = ifelse(OR <= 1, -1, 1)) %>%
select(group, YearsPrescription, MED_NAME, direction)
# number of sig hypotheses in stage 1
n_md_t1_1 <- nrow(ls_md_t1[ls_md_t1$group == "1", ])
# number of sig hypotheses in stage 2 that have the same direction
n_md_t1_2 <- intersect(ls_md_t1[ls_md_t1$group == "1", -1], ls_md_t1[ls_md_t1$group == "2", -1]) %>%
nrow()
## T2: Median original and replication effect sizes
# convert effect size to r (which is 0,1 bounded and nicely interpretable)
# cf. https://easystats.github.io/effectsize/reference/d_to_r.html
ls_md_t2 <- ls_md %>%
mutate(effect = effectsize::oddsratio_to_r(OR, Y, N)) %>%
na.omit
# effect size estimates between stages
p_md_t2 <- ls_md_t2 %>%
group_by(group) %>%
summarize(mean = mean(effect), sd = sd(effect), median = median(effect))
# p-value: t-test to compare effect size estimates between stages
stats_md_t2 <- ls_md_t2 %>%
summarize(pval = t.test(effect ~ group)$p.value)
## T3: Percent original effect size within replication 95% CI
ls_md_t3 <- ls_md %>%
filter(group == "1") %>%
mutate(is_within = FALSE)
for(i in 1:nrow(ls_md_t3)){
row_stage1 <- ls_md[i ,]
row_stage2 <- ls_md[ls_md$MED_NAME == row_stage1$MED_NAME &
ls_md$group == "2" &
ls_md$YearsPrescription == row_stage1$YearsPrescription, ]
# get OR 95% CI; fails for very small sample sizes; if so, skip
possibleError <- tryCatch(
expr = {
row_stage1 <- getCI(row_stage1)
row_stage2 <- getCI(row_stage2)
},
error = function(e){
e
}
)
if(inherits(possibleError, "error")) next
# check if OR of group 1 is within CI1 and CI2 of group 2
is_within <- (row_stage1$OR > row_stage2$CI1) & (row_stage1$OR < row_stage2$CI2)
# store in dataframe of just group 1 hypotheses
ls_md_t3[i ,]$is_within <- is_within
}
stats_md_t3 <- nrow(ls_md_t3[ls_md_t3$is_within == "TRUE", ])/nrow(ls_md_t3[ls_md_t3$is_within == "FALSE", ])
## PLOT
ls_md_dfp <- ls_md_t2 %>%
select(MED_NAME, YearsPrescription, group, effect) %>%
pivot_wider(names_from = "group", values_from = "effect") %>%
# keep p-value
left_join(ls_md_t3[ls_md_t3$group == "1", ][ ,c("MED_NAME", "YearsPrescription", "P")]) %>%
mutate(is_sig = ifelse(P < 0.05, 1, 0)) %>%
mutate(is_sig = as.factor(is_sig))
ls_md_p <- ls_md_dfp %>%
ggplot(aes(x = `1`, y = `2`, color = is_sig)) +
geom_point() +
scale_x_continuous(limits = c(-.4, .4)) +
scale_y_continuous(limits = c(-.4, .4)) +
theme_classic() +
theme(legend.position = c(.8, .2)) +
scale_color_manual(values = pal_rep,
labels = c("P > 0.05", "P < 0.05"), "") +
coord_fixed() +
xlab("Stage 1 Effect Size\nMedical treatment") +
ylab("Stage 2 Effect Size\nMedical treatment") +
geom_smooth(method = lm, se = FALSE) +
stat_cor(method = "pearson",
geom = "label",
label.npc.y = 0.01,
label.x.npc = 0.01) +
guides(color = guide_legend(override.aes = list(linetype = c(1, 1),
alpha = 0,
shape = c(10, 10))))
ls_md_p <- ggExtra::ggMarginal(ls_md_p,
type = "histogram",
groupFill = TRUE,
groupColour = TRUE)
### EXPORT ---------------------------------------------------------------------
## effect size correlation plots
ls_p <- cowplot::plot_grid(ls_cs_p, ls_lg_p, ls_md_p, nrow = 1, labels = "AUTO")
pdf(file = "FigRep.pdf",
width = 12,
height = 4)
ls_p
dev.off()
nrow(ls_lg_t3[ls_lg_t3$is_within == "TRUE", ])
nrow(ls_lg_t3[ls_lg_t3$is_within == "FALSE", ])
stats_lg_t3
p_lg_t2
stats_lg_t2
ls_lg_t3
stats_lg_t3
n_lg_t1_1
n_lg_t1_2
452/1021
df_asm
length(unique(df_asm$MedicalRecordNumber))
length(unique(df_match1$MedicalRecordNumber))
df-match1
df_match1
length(unique(df_match1$PatientId))
df_lookup
df_med
length(unique(df_med$MedicalRecordNumber))
length(unique(df_med$PatientId))
df_med
length(unique(df_med$MedicalRecordNumber))
df_heatmap
df_match1 %>%
# merge in patient ID and group label
distinct(PatientId, group) %>%
left_join(df_med, by = "PatientId") %>%
na.omit
tmp <- df_match1 %>%
# merge in patient ID and group label
distinct(PatientId, group) %>%
left_join(df_med, by = "PatientId") %>%
na.omit
length(unique(tmp$PatientId))
length(unique(df_match1$PatientId))
tmp
tmp %>% distinct
266/344
stats_med_sub
stats_med_resc
p_med_sub
0.000000451
p_med_resc
df_concepts
df_conceptmatch
0.00000660
0.00000152
ls_md_t1
n_md_t1_1
n_md_t1_2
29/51
p_md_t2
stats_md_t2
nrow(ls_md_t3[ls_md_t3$is_within == "TRUE", ])
nrow(ls_md_t3[ls_md_t3$is_within == "FALSE", ])
stats_md_t3
?cor.test
df_person
df_person
### DEMOGRAPHICS ---------------------------------------------------------------
tbl_person <- df_person %>%
filter(PatientId %in% df_match1$PatientId) %>%
mutate(Gender = recode(Gender,
"C0086582" = "Male",
"C0086287" = "Female")) %>%
mutate(Ethnicity = recode(Ethnicity,
"C1518424" = "Not Hispanic or Latino",
"C1549625" = "Unknown",
"C5441846" = "Hispanic or Latino",
"None" = "Unknown")) %>%
summary_factorlist(dependent = "GENEPOS_comb",
explanatory = c("Gender", "Ethnicity", "ProcAge",
"min_age", "median_age", "max_age"),
p = TRUE, na_include = TRUE)  %>%
knitr::kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
tbl_person
enrich1$data
enrich1$data %>%
filter(description %like% "Febrile seizure")
enrich1$data %>%
filter(description %like% "Simple febrile seizure")
